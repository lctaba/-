如果用户短时间内快速点击发送了两次请求，就会产生两次更新操作，如果是转账-100元可能会转好几个100。因此需要解决这个问题。





## post不幂等而put幂等

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

## 用post方法，不用-100，而是用set

如果发送10个-100请求，那么会-1000。但是发送10个set100请求，结果还是100.

## 加锁：

#### 缓存中加锁：（不行）

对于同样的请求，在即将进行查找的时候就将其作为key放到缓存中，这样下一个请求过来就可以直接在缓存中找到。

但是有一个问题，那就是缓存中此时还没有查询到的数据。（可以通过某个特定的标志识别？）（不行，更新了之后缓存都删除了）

#### 加悲观锁（解决同时多个请求导致余额变为负数）

给每次数据库操作都加上悲观锁，锁定该数据行。（必须是主键或唯一索引，否则会锁住整张表）

#### 加乐观锁

利用一个字段进行标记。如（timestamp，version）操作之后。更新前先查询数据，用查到的timestamp和version再作为条件进行更新，如果前面已经更新了那么timestamp和version就改变了，防止了多次更新。

但是如果是连续点击好几次还有一种情况：更新了之后才查到。这样先查就不能解决问题了。这时候可能要使用业务流程中的东西。比如付款时他的version标志为2，付款后version标志为3。那么一开始发送更新请求的时候就把version为2作为条件。更新之后变为3其他的请求就失效了。（也叫更新状态机）。

## 唯一索引：插入两条相同的数据

唯一索引一半用唯一的列，如身份证号等。因为他们有业务属性因此不适合做主键。

