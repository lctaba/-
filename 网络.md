## TCP

头部：

- 原始端口，目的端口

- 数据序号 seq

- 确认序号 ack
- ack标志位：只有ack标志位为1时，确认序号ack才有效。
- 紧急数据指针：URG：用于表明是紧急数据
- 复位比特：RST：说明TCP出现严重差错，必须重新连接

- 同步比特SYN

- 终止比特FIN

- 校验和

用户数据：



#### 三次握手（第三次握手允许携带数据）

客户端：SYN=1  seq=n

服务器：SYN=1  ACK=1(标志位)   ack=n+1   seq=m 

客户端：ACK=1  ack=m+1

**用于建立连接，用于客户端与服务端交换ISN，让对方直到接下来数据的序号**

**SYN攻击**：客户端在短时间内伪造大量不存在的ip，然后向服务器发送SYN包，服务器返回之后需要客户端进行确认。但是ip是伪造的所以客户端根本不会回应。然后服务器就一直重发直到超时，导致其他正常的请求被阻塞或者因为队列满了而被丢弃。（DDos攻击）

**解决**：发现服务器上有大半处于半连接状态而且ip是随机的（半连接状态：服务器发送了第二次握手的包但是没有收到客户端的确认）

**ISN初始化序列号**：需要随机生成，如果每次连接都使用同样的ISN，很容易被攻击者推断出。

但是抓包也能获取ISN啊？抓包只存在于同一个网络中，能避免不同网络的攻击。

**避免历史连接**：客户端建立连接时发送多次 SYN 报文，由于网络拥堵可能旧的 SYN 报文比新的 SYN 报文先到服务器，服务器不管新旧，收到就回复 SYN + ACK 给客户端，三次握手情况下客户端可以根据序列号或超时时间判断回复的连接是否是历史连接，如果是历史连接直接发送 RST 报文给服务端来终止连接。





#### 四次挥手

客户端：FIN=1  seq=n  客户端告诉服务器自己不发数据了，要关闭连接，但还可以接受数据。

服务器：ACK=1  ack=n+1  服务器告诉客户端说我已经收到了关闭连接的请求了，但是我这边还不打算关闭。

服务器：FIN=1    seq=m   服务器告诉客户端我也不发数据了，要关闭连接，等你确认。

客户端：ACK    ack=m+1  等待服务器重传（两个最大生命周期，确保两端发送的数据包全部失效）第三次回收，如果服务器不重传，说明已经收到了确认，就可以关闭连接了。

为什么是四次挥手？

如果只是三次挥手，可能服务器还有数据没发完，客户端就关闭了，会造成数据的丢失。





#### 拥塞控制

当前窗口大小：c     门限：s

慢开始：当c<s，c=c*2；

拥塞避免：c>s，c++，拥塞（丢包）之后c=1，s=c/2，然后慢开始；

快重传：收到失序报文就立即发出重复确认，连续收到三个重复确认就重发报文，而不用等到重传计时器到期。因为这并不是应为网络拥堵而丢包。

快恢复：当满足快重传条件时，s=c/2，c=s，然后进行拥塞避免算法。



## UDP

头部：

- 源端口
- 目标端口
- 长度
- 校验和

数据内容：



无连接、不能分包、不能对数据包进行排序，是不可靠传输。

有单播，多播，广播功能。

UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此应用程序必须选择合适大小的报文

头部开销小



## 域名解析

查找www.baidu.com：

先去根域名找，根域名说要去com的顶级域名服务器找

顶级域名服务器说要去baidu的域名服务器找

就这样一直找下去



但是这样所有流量都到根域名了，根域名不是裂开？

所以一些公司就用自己的DNS服务器代替用户请求根域名服务器。如果缓存中有的，就直接返回，如果没有再去请求根域名服务器。

本地也会缓存



所以真正的流程：

先找本地缓存，找到了就直接用。

找不到再去非权威域名的服务器找。



递归查询：客户访问了之后由服务器代替查询，直接返回给客户端结果。

迭代查询：客户访问了之后服务器告诉客户端改去哪里查，客户端自己去查。 