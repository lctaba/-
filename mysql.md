## 事物的隔离级别

- READ UNCOMMITED（读未提交）

事物中的修改没有提交其他事物也可见

会导致脏读

- READ COMMITTED（读已提交）

一个事物只能读取已经提交的事物数据，但是这可能导致同一个食物中两次读取的内容不一致

导致不可重复读

- **Repeatable read**可重复读

幻读：可重复读只解决了修改操作，但是没有解决插入操作。第一次读了之后其他线程进行插入操作，那么第二次读就会多出一条数据。

- Serializable 串行化



## 读锁写锁

在修改的时候加上写锁，这时不能再对其进行写操作，可以防止数据覆盖

在读的时候加上读锁，读完了再释放，其他线程不能再对其进行写操作，防止了脏读

在读的时候加上写锁，事务完成了再释放，可以防止不可重复读



## 存储引擎innodb myisam

innodb支持事务，myisam不支持事务

myisam不支持行级锁，只支持全表加锁



## sql语句执行流程（执行顺序）





## 索引

- b+tree

  - 不需要全表扫描只需要对树搜索
  - 可以用多个索引列组成一个健
  - InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。（主索引将文件分块，每一块对应一个索引项，主索引要求key是唯一的）。innodb数据文件本身也是索引文件，本身就是通过B+tree组织的索引结构。
  - 在innodb中，辅助索引是引用主键作为data域，需要检索两次

  ![image-20210407210058674](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20210407210058674.png)

  - 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。（辅索的值有可能相同，因此需要一个中间桶保存指针列表）
  - 在myisam中，主索引和辅索引在结构上是没有区别的，只是可不可以重复的问题。所以叫做非聚集的。索引文件和数据文件是分离的，索引文件只保存了对应数据的地址。![image-20210407205952916](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20210407205952916.png)

- 可以得出结论：不要用长的字段作为主键，因为这样的话会让辅助索引都变得很大。

- 不单调的字段作为innodb的主键不合适，因为innodo的数据文件本身就是b+tree，非单调主键会导致插入的时候需要频繁分裂。



- hash索引能o（1），但失去了排序。无法排序与分组，只支持精确查找，不支持范围查找。
  - innodb有个自适应hash，当某个索引值用得非常频繁，就会再为其建立一个hash索引。



## 索引优化

- 索引不能是表达式的一部分，也不能说参数，否则无法使用索引。
- 多列索引：用多个列进行查询时，可以设置多列索引。
- 索引顺序：让选择性最强的索引放在前面。
- 前缀索引：用于字符串

#### 索引使用条件

- 对于小的表，全表扫描效率更高。
- 中到大的表索引效率很高。
- 大型的表维护索引的代价也会随之增高，可以使用分区技术或者分表。



## 切分

#### 水平切分

将一张表中的数据拆成两张表

#### 垂直切分

通常将常用的列和不常用的列进行切分。



#### 读写分离

减少加锁，缓存的效率提高



## 主键自增的问题

分表会有问题。不好拓展（多个服务器可以设置自增步长）

主键可能会重复

锁表问题：该实现方式是通过表锁机制来完成的（AUTO-INC LOCKING）。锁不是在每次事务完成后释放，而是在完成对自增长值插入的SQL语句后释放，要等待其释放才能进行后续操作。比如说当表里有一个auto_increment字段的时候，innoDB会在内存里保存一个计数器用来记录auto_increment的值，当插入一个新行数据时，就会用一个表锁来锁住这个计数器，直到插入结束。如果大量的并发插入，表锁会引起SQL堵塞。

