## 内核态和用户态

用户代码运行在用户态，当要用户态下没能力完成一些操作时就进入内核态。（通过系统调用，或者发生异常，或者外围设备中断）

## 系统调用

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |





分页虚拟内存的好处：防止内存碎片，可以运行大内存文件而不需要一次把程序全部调入内存。



![image-20210304164917624](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20210304164917624.png)

程序中除了数据以外就是指令。

虚拟空间分为用户空间与内核空间。

1.用户空间：

- 初始化不为0的静态变量储存在.data段，初始化为0或未初始化的静态变量放在.bss段，字符串常量存放在.rodata段。

- 栈.stack段存放局部变量，如参数，内部变量。函数调用时，参数就会压入栈中，，返回值也会放入栈中。每调用一次函数会创建一个新的栈。栈的地址有高地址向低地址增长。

- 堆段heap存放动态分配的内存。地址由低到高。

- 文件映射段，共享段，储存共享内存与动态链接库。
- 代码段.text段存放程序执行代码（指令），也会存放只读的常量。该段只读。
- 不可访问是防止访问空指针。如int* p = NULL，不能访问，NULL的地址为0x00000000。

2.内核空间：

在虚拟地址空间中，每个程序都有独立的内核空间。但是不同进程的内核空间在物理内存中是同一块。



经过编译将代码转变为二进制可重定位的目标文件。

ELF header占64个字节，里面存放着文件类型、支持的平台、程序入口点地址等信息

![image-20210304165243995](C:\Users\86150\AppData\Roaming\Typora\typora-user-images\image-20210304165243995.png)

链接过程：

- 合并段：将相同属性的段合并到一个页面上，比如.text段和.rodata段都是可读可执行，整合到一个页面。
- 合并符号表
- 符号解析
- 分配内存地址：符号解析完之后，将逻辑地址转为虚拟地址，然后映射到物理地址上。
- 符号重定位：因为在编译过程中不分配地址，所有在目标文件所以数据出现的地方都给的是零地址，所有函数调用的地方给的是相对于下一条指令的地址的偏移量。在符号重定位时，要把分配的地址回填到数据和函数调用出现的地方，而且对于数据而言填的是绝对地址，而对函数调用而言填的是偏移量。





直接使用物理内存的不足：可以直接访问内存，缺乏访问控制，安全性不足。

各进程访问时可能会相互干扰。

物理内存小，内存可能不足。

各个进程所需要的空间不一致，导致内存碎片。





#### 页面置换算法：

用来尽可能地减少页面置换的次数，使缺页率最低。

- 最近最久未使用

- 先进先出FIFO
- 第二次机会算法，改进的FIFO：当页面被访问过后就将其中的一个标志位记为1，当要被替换时如果标志位是1则将其变为0，然后找下一个。
- 时钟算法：因为第二次机会算法需要在从头到尾链表中移动页面，因此用时钟将页面连接起来，用指针标记出最老的页面。

#### 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

#### 分段与分页

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

