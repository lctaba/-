## 缓存IO

操作系统将数据缓存在文件系统的页缓存中，数据会先被拷贝到操作系统内核的缓存区中，然后才会从操作系统内核的缓冲区中拷贝到应用程序的地址空间。

- 缺点：要在内核于程序地址空间中进行多次数据拷贝操作，CPU和内存的开销非常大



## 	linux	io

#### 同步阻塞IO

进程存在两种状态：等待数据和处理数据，等待数据的过程中什么也不干，直到数据准备好从内核复制到用户进程，整个进程被阻塞。

有两个阶段：1.准备数据，等待数据全部到达2.当数据准备好，将数据拷到程序的地址空间。

- 特点：IO执行的两个阶段都被阻塞了

- 优点：及时返回数据，无延迟
- 缺点：性能差

read操作，如果客户端一直不发送数据，那么服务端线程会一直阻塞在read上



#### 同步非阻塞IO

需要不断询问数据是否准备就绪（轮询）

当产生recvform系统调用之后，进程没有阻塞，而是返回一个error表示数据还没有准备好。如此轮询，直到数据准备好了。但是拷贝的过程中，进程仍然是处于阻塞状态。

优点：第一阶段不需要阻塞了

缺点：相应的延迟增大了，数据可能在两次轮询之间准备完



或者开启一个新的线程，使得主线程不会阻塞，这样通过客户端的小把戏不算真正的复用。



#### IO多路复用

不需要进程自己主动去查询数据的准备状态了，而是可以同时监听多个IO端口，当某个IO端口准备就绪，进程就可以进行读取，将监听的工作交给了内核，将等待数据和读取实际数据分开。

